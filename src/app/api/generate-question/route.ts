import { NextResponse } from "next/server";

interface TestCase {
  arguments: any[]; // Changed from input to arguments array
  output: string | object;
}

interface ParsedQuestion {
  title: string;
  description: string;
  function_name: string; // New field for the function name
  function_signature: string;
  test_cases: TestCase[];
  // test_script removed as we generate it on client side
}

export async function POST(request: Request) {
  try {
    const { difficulty, userCode } = await request.json(); // Destructure userCode

    if (!difficulty) {
      return NextResponse.json(
        { error: "Difficulty field is missing" },
        { status: 400 },
      );
    }

    const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;

    if (!OPENROUTER_API_KEY) {
      return NextResponse.json(
        { error: "OPENROUTER_API_KEY is not set" },
        { status: 500 },
      );
    }

    const response = await fetch(
      "https://openrouter.ai/api/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${OPENROUTER_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "arcee-ai/trinity-large-preview:free",
        messages: [
          { role: 'system', content: 'You are a helpful assistant that generates Leetcode-esque Python programming questions. The output must be a JSON object with the following structure: {"title": "string", "description": "string", "function_name": "string", "function_signature": "string", "test_cases": [{"arguments": ["string", "string"], "output": "string"}]}. The `function_name` should be the name of the function defined in `function_signature`. The `test_cases` should have an `arguments` field which is an array of strings, where each string is a valid Python literal representing one positional argument, and an `output` field which is a string representing the return value. The arguments and output should be valid Python literals (e.g., "[1, 2]" for a list argument, "5" for an integer argument, "\"hello\"" for a string argument). Ensure the JSON is valid and complete.' },
          { role: 'user', content: `Generate a ${difficulty} difficulty Leetcode-esque question in Python. Provide the question in the specified JSON format.${userCode ? `\n\nUser's current code:\n\`\`\`python\n${userCode}\n\`\`\`` : ''}` },
        ],
      }),
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      console.error("OpenRouter API error:", errorData);
      return NextResponse.json(
        {
          error: "Failed to generate question from OpenRouter API",
          details: errorData,
        },
        { status: response.status },
      );
    }

    const data = await response.json();
    const generatedQuestionContent = data.choices[0]?.message?.content;

    if (!generatedQuestionContent) {
      return NextResponse.json(
        { error: "No question generated by the API" },
        { status: 500 },
      );
    }

    let parsedQuestion;
    let cleanedQuestionContent = generatedQuestionContent;

    // Check if the content is wrapped in a JSON code block and remove delimiters
    const jsonCodeBlockRegex = /```json\s*([\s\S]*?)\s*```/;
    const match = generatedQuestionContent.match(jsonCodeBlockRegex);

    if (match && match[1]) {
      cleanedQuestionContent = match[1];
    }

    try {
      parsedQuestion = JSON.parse(cleanedQuestionContent) as ParsedQuestion;
    } catch (parseError: unknown) {
      console.error("Error parsing generated question JSON:", parseError);
      let errorMessage = "Unknown parsing error";
      if (parseError instanceof Error) {
        errorMessage = parseError.message;
      }
      return NextResponse.json(
        {
          error: "Failed to parse generated question JSON",
          details: errorMessage,
        },
        { status: 500 },
      );
    }

    const {
      title,
      description,
      function_signature,
      function_name,
      test_cases,
    } = parsedQuestion;

    let formattedTestCases = "";
    if (test_cases && test_cases.length > 0) {
      // Helper to ensure values are stringified if they aren't already string representations
      const formatValue = (val: string | object | number | boolean): string => {
        if (typeof val === "string") return val;
        return JSON.stringify(val);
      };

      formattedTestCases = test_cases
        .map((tc: TestCase) => {
          const args = Array.isArray(tc.arguments)
            ? tc.arguments
            : [tc.arguments];
          const argsStr = args.map((arg) => formatValue(arg)).join(", ");
          return `\`\`\`python\nInput: ${argsStr}\nOutput: ${formatValue(tc.output)}\n\`\`\``;
        })
        .join("\n\n");
    }

    const formattedQuestion = `
## ${title}
 
### Description
${description}
 
### Function Signature
\`\`\`python
${function_signature}
\`\`\`
 
### Test Cases
${formattedTestCases || "No test cases provided."}
    `.trim();

    return NextResponse.json(
      {
        question: formattedQuestion,
        functionName: function_name,
        testCases: test_cases,
      },
      { status: 200 },
    );
  } catch (error) {
    console.error("Error in generate-question API route:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 },
    );
  }
}
